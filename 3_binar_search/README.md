# Бинарный поиск

---
[Я.Контест](https://contest.yandex.ru/contest/24735/problems/A/)

<details>
<summary>
<b>Поиск в сломанном массиве (<a href="broken_search.py">broken_search.py</a></b>)
</summary>

#### Условие

Алла ошиблась при копировании из одной структуры данных в другую.
Она хранила массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию,
и в нём можно было найти элемент за логарифмическое время.
Алла скопировала данные из кольцевого буфера в обычный массив,
но сдвинула данные исходной отсортированной последовательности.
Теперь массив не является отсортированным.
Тем не менее, нужно обеспечить возможность находить в нем элемент за O(logn).
Можно предполагать, что в массиве только уникальные элементы. 

#### Формат ввода

Функция принимает массив натуральных чисел и искомое число k.
Длина массива не превосходит 10000. Элементы массива и число k не превосходят по значению 10000.
В примерах:
В первой строке записано число n –— длина массива.
Во второй строке записано положительное число k –— искомый элемент.
Далее в строку через пробел записано n натуральных чисел – элементы массива. 

#### Формат вывода

Функция должна вернуть индекс элемента, равного k,
если такой есть в массиве (нумерация с нуля). Если элемент не найден, функция должна вернуть −1.
Изменять массив нельзя.

#### Пример

<table>
  <tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">9<br>5<br>19 21 100 101 1 4 5 7 12</td>
  <td valign="top">6</td>
  </tr>
  </tbody>
</table>
<table>
  <tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">2<br>1<br>5 1</td>
  <td valign="top">1</td>
  </tr>
  </tbody>
</table>
</details>

---

[Я.Контест](https://contest.yandex.ru/contest/24734/problems/L/)

<details>
<summary>
<b>Два велосипеда (<a href="two_bicycles.py">two_bicycles.py</a></b>)
</summary>

#### Условие

Вася решил накопить денег на два одинаковых велосипеда — себе и сестре.
У Васи есть копилка, в которую каждый день он может добавлять деньги
(если, конечно, у него есть такая финансовая возможность). В процессе накопления Вася не вынимает деньги из копилки.
У вас есть информация о росте Васиных накоплений — сколько у Васи в копилке было денег в каждый из дней.
Ваша задача — по заданной стоимости велосипеда определить

первый день, в которой Вася смог бы купить один велосипед,
и первый день, в который Вася смог бы купить два велосипеда.

Решение должно работать за O(log n).

#### Формат ввода

В первой строке дано число дней n,
по которым велись наблюдения за Васиными накоплениями. 1 ≤ n ≤ 106.
В следующей строке записаны n целых неотрицательных чисел.
Числа идут в порядке неубывания. Каждое из чисел не превосходит 106.
В третьей строке записано целое положительное число s — стоимость велосипеда. 
Это число не превосходит 106.

#### Формат вывода

Нужно вывести два числа — номера дней по условию задачи.
Если необходимой суммы в копилке не нашлось, нужно вернуть -1 вместо номера дня.

#### Пример

<table>
  <tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">6<br>1 2 4 4 6 8<br>3</td>
  <td valign="top">3 5</td>
  </tr>
  </tbody>
</table>
<table>
  <tbody>
  <tr>
    <td><b>Ввод</b></td>
    <td><b>Вывод</b></td>
  </tr>
  <tr>
    <td valign="top">6<br>1 2 4 4 4 4<br>10</td>
  <td valign="top">-1 -1</td>
  </tr>
  </tbody>
</table>
</details>

---